= Lecture Notes 5AHITM SEW 20/21
Thomas W. Stütz
1.0.0, 2020-09-25: Lecture Notes
ifndef::imagesdir[:imagesdir: images]
//:toc-placement!:  // prevents the generation of the doc at this position, so it can be printed afterwards
:sourcedir: ../src/main/java
:icons: font
:sectnums:    // Nummerierung der Überschriften / section numbering
:toc: left

//Need this blank line after ifdef, don't know why...
ifdef::backend-html5[]

// https://fontawesome.com/v4.7.0/icons/
// icon:file-text-o[link=https://raw.githubusercontent.com/htl-leonding-college/asciidoctor-docker-template/master/asciidocs/{docname}.adoc] ‏ ‏ ‎
icon:github-square[link=https://github.com/2021-5ahitm-sew/5ahitm-sew, window="_blank"]
// icon:home[link=https://htl-leonding.github.io/]
endif::backend-html5[]

// print the toc here (not at the default position)
//toc::[]


////
== 2020-09-24

=== Referate

.Termin
|===
|Wer |Was |Bis wann?

|Stütz
|Liste der Referatsthemen
|1. Okt. 2020

|Stütz
|Referatstermine festlegen
|1. Okt. 2020

|Stütz
|RevealJs Repo zur Verfügung stellen
|1. Okt. 2020

|===

==== Sources

* https://github.com/bentolor/java9to13[Asciidoctor & RevealJS - Source, window="_blank"]
* https://bentolor.github.io/java9to13[Asciidoctor & RevealJS - Presentation, window="_blank"]
* https://www.pexels.com/[Pexels, window="_blank"]
* https://undraw.co[UnDraw, window="_blank"]
* https://unsplash.com/[unsplash, window="_blank"]
* https://plantuml.com/class-diagram[plantUml]




=== Verwendung von plantuml in Asciidoctor

[plantuml,xxx,png]
----
@startuml
class Person {
  name: String
  hobbies: List<Hobby>
}

class Hobby {
  person: Person
}
Person <--- Hobby : übt aus >
Person ---> Hobby
@enduml
----

[source,java]
----
Hobby hobby = new Hobby();
hobby.person = new Person();

Person person = hobby.person;
----


[plantuml,jenkins,png]
----
@startuml
rectangle gitrepo
queue jenkins{
    file java
    storage compile
    file class
    storage package
    file jar
    storage test
    storage deploy
}
gitrepo -> java
java -> compile
compile -> class
class -> package
package -> jar
jar -> test
test -> deploy
@enduml
----
////

====
* Termin der Leistungsfeststellung 23.11.2020
* Termin der Prüfungen 22.1.2021
====

== 2020-09-25

=== Übung WebSocket, SSE und gRPC

Erstellen Sie gemäß Ihrem Thema ein Projekt und implementieren Sie untenstehende Technologien:

* https://quarkus.io/guides/websockets[WebSockets, window="_blank"]
* SSE
* https://quarkus.io/guides/grpc-getting-started[gRPC, window="_blank"]

.Weitere Aufgaben:
* Testen Sie die einzelnen Technologien automatisiert
* Dokumentieren Sie die einzelnen Technologien in Form von gh-pages mit Asciidoctor
** Einsatzgebiet von gRPC (Welches Problem wird gelöst)
** Alternativen zu gRPC
** Grundlegende Funktionsweise von gRPC
** Dokumentieren Sie die automatisierten Tests
* Pushen Sie das Endergebnis sowie die Zwischenergebnisse hierhin: https://classroom.github.com/a/WHJoF_6T

== 2020-10-02

* Was ist gRPC
** Alternative zu REST
** binär
** sehr effizient und performant
** ...

* Feedback zu Übungen

* Ansehen der Definition von gRPC lt. https://www.youtube.com/watch?v=nt9haFAQUL8[Rainer Stropek - gRPC mit C#]


== 2020-11-06

* Asynchronous persistence with Mutiny

== 2020-11-09

=== Logging in Jakarta EE (Quarkus)

https://quarkus.io/guides/logging

* Es wird empfohlen den jboss-Logger zu verwenden.


[source,java]
----
@ApplicationScoped
public class GreetingService {

    private static final Logger logger = Logger
            .getLogger(GreetingService.class.getSimpleName()); // <.>

    int counter;

    public String greeting(String name) {
        logger.info(String.format("Hello %s (%d x verwendet)", name, ++counter)); // <.>
        return String.format("Hello %s (%d x verwendet)", name, ++counter);
    }
}
----
<.> Man muss einen Logger deklarieren. Der Klassenname wird übergeben.
<.> Man kann den Logger verwenden

.Output des Loggers in Console
----
2020-11-06 09:40:53,795 INFO  [at.htl.con.GreetingService] (executor-thread-198) Hello susi (1 x verwendet!)
----

* Es gibt *Log-Levels*
** INFO
** ERROR
** FATAL
** DEBUG
** ...

* Es gibt sogenannte *Appender* zur Ausgabe auf verschiedenen Medien
** Konsole
** in Text-Files (auch rotierend)
*** zB 3 Files mit einer bestimmten Größe (zB 10k).
*** Sind alle 3 Files beschrieben, wird das erste File gelöscht und neu beschrieben
*** Vorteile:
**** Der Speicher (Festplatte) wird nicht vollgeschrieben
**** Es stehen immer Log-Meldungen aus der Vergangenheit zur Verfügung
** in Datenbanken
** auf einen REST-Endpoint
** https://geekflare.com/open-source-centralized-logging/[Log-Collector] zB https://docs.graylog.org/en/3.3/pages/installation/docker.html#here[GrayLog]
** ...

==== Logging mit Dependency Injection

Man kann auch einen Logger mit DI injizieren

.Erstellen des Producers
[source,java]
----
public class LoggerProducer {

    @Produces
    public Logger produceLogger(InjectionPoint injectionPoint) {
        return Logger.getLogger(injectionPoint.getBean().getBeanClass());
    }
}
----

.Verwendung des injizierten Loggers
[source,java]
----
@ApplicationScoped
public class GreetingService {

    @Inject
    private Logger logger; // <.>

    int counter;

    public String greeting(String name) {
        logger.info(String.format("Hello %s (%d x verwendet!)", name, ++counter)); // <.>
        return String.format("Hello %s (%d x verwendet!)", name, ++counter);
    }

}
----

<.> Die Logger Klasse wird injiziert.
<.> Die Verwendung bleibt gleich

=== git blame
https://htl-leonding-college.github.io/git-lecture-notes/#_blame_for_finding_the_author_of_a_line

=== git tag
https://htl-leonding-college.github.io/git-lecture-notes/#_tagging

=== Semantic Versioning

https://semver.org/lang/de/

== 2020-11-13

=== Quarkus mit Kotlin





[source,java]
----

----





[source,java]
----

----





[source,java]
----

----





[source,java]
----

----





[source,java]
----

----





[source,java]
----

----





[source,java]
----

----





[source,java]
----

----



